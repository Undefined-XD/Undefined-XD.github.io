<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="基础概念术语： JVM：Java 虚拟机是 Java 程序的运行环境，不同的操作系统上有不同的 JVM，它们能够运行现有的 Java 程序。 JRE：Java 运行时环境，其中包含 JVM 和运行时所需要的核心类库等。 JDK：Java 开发工具，包含 JRE 和相关开发工具。  命令行窗口命令： Javac 是 Java 编译器，负责将写好的 xxx.java 源代码进行编译，得到 xxx.cl">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE学习笔记">
<meta property="og:url" content="http://yoursite.com/2020/03/22/JavaSE学习笔记/index.html">
<meta property="og:site_name" content="HXJ&#39;s Blog">
<meta property="og:description" content="基础概念术语： JVM：Java 虚拟机是 Java 程序的运行环境，不同的操作系统上有不同的 JVM，它们能够运行现有的 Java 程序。 JRE：Java 运行时环境，其中包含 JVM 和运行时所需要的核心类库等。 JDK：Java 开发工具，包含 JRE 和相关开发工具。  命令行窗口命令： Javac 是 Java 编译器，负责将写好的 xxx.java 源代码进行编译，得到 xxx.cl">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/Users/hxj/Documents/GitHub/hexo/Blog/source/_posts/image-20200310215114574.png">
<meta property="og:updated_time" content="2020-03-26T05:08:14.307Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaSE学习笔记">
<meta name="twitter:description" content="基础概念术语： JVM：Java 虚拟机是 Java 程序的运行环境，不同的操作系统上有不同的 JVM，它们能够运行现有的 Java 程序。 JRE：Java 运行时环境，其中包含 JVM 和运行时所需要的核心类库等。 JDK：Java 开发工具，包含 JRE 和相关开发工具。  命令行窗口命令： Javac 是 Java 编译器，负责将写好的 xxx.java 源代码进行编译，得到 xxx.cl">
<meta name="twitter:image" content="http://yoursite.com/Users/hxj/Documents/GitHub/hexo/Blog/source/_posts/image-20200310215114574.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>JavaSE学习笔记</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
<link rel="alternate" href="/atom.xml" title="HXJ's Blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="http://47.98.43.70">项目</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/03/26/Spring框架学习/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/03/21/MySQL学习笔记/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/03/22/JavaSE学习笔记/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&text=JavaSE学习笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&is_video=false&description=JavaSE学习笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaSE学习笔记&body=Check out this article: http://yoursite.com/2020/03/22/JavaSE学习笔记/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&name=JavaSE学习笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础概念"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#术语："><span class="toc-number">1.1.</span> <span class="toc-text">术语：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行窗口命令："><span class="toc-number">1.2.</span> <span class="toc-text">命令行窗口命令：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型："><span class="toc-number">1.3.</span> <span class="toc-text">基本数据类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-number">1.4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义方法"><span class="toc-number">1.5.</span> <span class="toc-text">定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载"><span class="toc-number">1.6.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建数组"><span class="toc-number">1.7.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的三个特征"><span class="toc-number">1.8.</span> <span class="toc-text">面向对象的三个特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的定义"><span class="toc-number">1.9.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的成员变量和成员方法"><span class="toc-number">1.10.</span> <span class="toc-text">类的成员变量和成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的构造方法"><span class="toc-number">1.11.</span> <span class="toc-text">类的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承"><span class="toc-number">1.12.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-的三种用法"><span class="toc-number">1.13.</span> <span class="toc-text">super 的三种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-的三种用法"><span class="toc-number">1.14.</span> <span class="toc-text">this 的三种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">1.15.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">1.16.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.17.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态字段和静态方法"><span class="toc-number">1.18.</span> <span class="toc-text">静态字段和静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代码块"><span class="toc-number">1.19.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问权限"><span class="toc-number">1.20.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量"><span class="toc-number">1.21.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-修饰符"><span class="toc-number">1.22.</span> <span class="toc-text">final 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">1.23.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个泛型"><span class="toc-number">1.24.</span> <span class="toc-text">多个泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.25.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-toString"><span class="toc-number">1.26.</span> <span class="toc-text">Object.toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等比较"><span class="toc-number">1.27.</span> <span class="toc-text">相等比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.28.</span> <span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建多线程"><span class="toc-number">2.1.</span> <span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的状态"><span class="toc-number">2.2.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断进程"><span class="toc-number">2.3.</span> <span class="toc-text">中断进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程"><span class="toc-number">2.4.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">2.5.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步方法"><span class="toc-number">2.6.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁"><span class="toc-number">2.7.</span> <span class="toc-text">可重入锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">3.2.</span> <span class="toc-text">Map</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        JavaSE学习笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">HXJ's Blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-03-21T23:53:31.000Z" itemprop="datePublished">2020-03-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/学习/">学习</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="术语："><a href="#术语：" class="headerlink" title="术语："></a>术语：</h3><ul>
<li>JVM：Java 虚拟机是 Java 程序的运行环境，不同的操作系统上有不同的 JVM，它们能够运行现有的 Java 程序。</li>
<li>JRE：Java 运行时环境，其中包含 JVM 和运行时所需要的<strong>核心类库</strong>等。</li>
<li>JDK：Java 开发工具，包含 JRE 和相关开发工具。</li>
</ul>
<h3 id="命令行窗口命令："><a href="#命令行窗口命令：" class="headerlink" title="命令行窗口命令："></a>命令行窗口命令：</h3><ul>
<li><p>Javac 是 Java 编译器，负责将写好的 xxx.java 源代码进行编译，得到 xxx.class 字节码文件；</p>
</li>
<li><p>Java 是 Java 运行器，负责将 xxx.class 文件进行运行；</p>
</li>
</ul>
<h3 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h3><table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">1字节</th>
</tr>
</thead>
<tbody><tr>
<td align="center">short</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4 字节</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4字节</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8字节</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">2字节</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">1字节</td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Java中涉及<strong>byte、short和char类型的运算操作首先会把这些值自动提升转换为int类型</strong>，然后对int类型值进行运算，<strong>最后得到int类型的结果</strong>。而long 和 float 本身取值范围大过int ，所以不想损失精度就要手动转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>; <span class="comment">// 以下三种类型的变量在赋值时，由int类型字面常量赋值给变量</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="number">1</span>;<span class="comment">// 虽然类型不符，但是因为过于常用，Java支持隐含的类型转换</span></span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">byte</span> b2 = i; <span class="comment">//而变量之间的赋值</span></span><br><span class="line">         <span class="keyword">char</span> c2 = i; <span class="comment">//即使不会发生数据的丢失</span></span><br><span class="line">         <span class="keyword">short</span> s2 = i; <span class="comment">//也不支持隐含的类型转换</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// printt(1);// 编译时会产生错误,10为int类型，而无对应方法</span></span><br><span class="line">        printt((<span class="keyword">short</span>) <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>char 类型在进行数学运算时是根据 ASCII 码数值进行计算的。</p>
<p>boolean 类型不能进行类型转换。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><ol>
<li>方法定义在 main() 方法之外，类之内。</li>
<li>方法不能产生嵌套包含关系，方法之间是平行关系。</li>
<li>方法的类型可以是任意的。</li>
</ol>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ol>
<li>多个方法的<strong>方法名相同</strong>，但是<strong>参数列表不同</strong><ul>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数类型顺序不同</li>
</ul>
</li>
<li>调用方法时自动根据传入的参数进行使用</li>
<li>参数列表的形参名字可以不同</li>
</ol>
<p><strong>注意：如果方法名相同，参数列表相同，返回值不同，不属于重载，会报错提示该函数已存在。但是，如果方法名相同，参数列表不同，返回值不同，那就是重载。</strong></p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol>
<li><p>动态创建，创建时指定长度</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">20</span>];</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">30</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态创建，创建时直接赋值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">double</span>[] arr = <span class="keyword">new</span> <span class="keyword">double</span>[] &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简略写法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>注意：前面两个步骤，= 左边两边是可以拆开来写的，但简略写法不能拆开来写。</strong></p>
<p><strong>数组元素有默认值，规则如下：</strong></p>
<ol>
<li>int 类型，默认值为 0</li>
<li>float / double 类型，默认值为 0.0</li>
<li>char 类型，默认值为 ‘\u0000’  (一个不可见字符)</li>
<li>boolean 类型，默认值为 false</li>
<li>引用类型，默认值为 null</li>
</ol>
<p><strong>注意：虽然静态创建和简略写法已经直接赋值，但是在数组创建过程当中仍然有默认值，随后才被新值替换。</strong></p>
<p><strong>java 内存划分成 5 个部分：</strong></p>
<ol>
<li>栈：存放方法的局部变量。</li>
<li>堆，存放 new 出来的对象，有一个十六进制的地址值，里面的数据有默认值。</li>
<li>方法区：存放.class 相关信息，包含方法的信息。</li>
<li>本地方法栈：与操作系统有关。</li>
<li>寄存器：与 CPU 有关。</li>
</ol>
<h3 id="面向对象的三个特征"><a href="#面向对象的三个特征" class="headerlink" title="面向对象的三个特征"></a>面向对象的三个特征</h3><ol>
<li>封装<ul>
<li>方法的封装</li>
<li><code>private</code> 对成员变量的修饰，可以阻止外界直接访问到该变量，并且由于通过间接设置的方式，也为我们对于试图改动这个变量的情况有了控制的能力。</li>
</ul>
</li>
<li>继承<ul>
<li>单继承，一个类只能有一个父类。</li>
<li>类之间可以多级继承。</li>
<li>一个子类的直接父类是唯一的，但一个父类可以有多个子类。</li>
</ul>
</li>
<li>多态<ul>
<li>多态即多种形态，一个对象可以有多种形态，体现对象的多态性。</li>
<li>多态的体现：父类引用指向子类对象。</li>
</ul>
</li>
</ol>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><ol>
<li><strong>成员变量直接定义在类当中，在方法外面。</strong></li>
<li><strong>成员方法不需要写 static 关键字。</strong></li>
</ol>
<h3 id="类的成员变量和成员方法"><a href="#类的成员变量和成员方法" class="headerlink" title="类的成员变量和成员方法"></a>类的成员变量和成员方法</h3><ol>
<li><p><code>private</code> 修饰的<strong>成员变量</strong>和<strong>成员方法</strong>，不能被外部直接访问到，只能类自身进行访问和赋值。</p>
</li>
<li><p><strong>类中的 <code>this</code> 始终指向当前实例。</strong></p>
</li>
<li><p>成员方法中的成员变量通过 <code>this.成员变量名</code>进行访问，避免成员变量名和传入的局部变量命名冲突。</p>
</li>
<li><p>如果基本类型的变量传入成员方法，成员方法获得的是值的赋值，该变量的后续修改不影响类中的相应变量值。</p>
</li>
<li><p>如果引用类型的变量传入成员方法，成员方法获得的是该对象的内存地址，成员变量也会指向同一个对象，任何一方对对象的修改都会影响另一方获取到的值。</p>
</li>
<li><p>可变参数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变参数用类型...定义，可变参数相当于数组类型：</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问成员变量的两种方式：</p>
<ol>
<li><p>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上查找。</p>
</li>
<li><p>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要应用在多态上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fu obj = <span class="keyword">new</span> Zi();</span><br><span class="line">System.out.println(obj.num); <span class="comment">// 结果使用 Fu 的 num 为10</span></span><br><span class="line"><span class="comment">// 情况一：只有 FU 中存在 showNum()</span></span><br><span class="line">obj.showNum(); <span class="comment">// 结果使用 Fu 的 num 为10</span></span><br><span class="line"><span class="comment">// 情况二：子类 @Override showNum()</span></span><br><span class="line">obj.showNum(); <span class="comment">// 结果使用 Zi 的 num 为2-</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问成员方法的方式：</p>
<ul>
<li>看 new 的是谁，就优先用谁，没有则向上找。</li>
<li>编译看左边，运行看右边。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h3><ol>
<li>一个类可以有多个不同参数列表的构造方法（方法重载）</li>
<li>实例在创建的时候通过<code>new</code>调用<strong>合适</strong>的构造方法（跟方法重载效果相同）</li>
<li>构造方法没有返回值，也不需要指定 <code>void</code> 。</li>
<li>一个类如果没有定义构造方法，编译器会自动生成一个参数和内容为空的构造方法。</li>
<li>在一个构造方法内部，可以 <code>this(不同参数列表)</code> 调用另一个构造方法，便于代码复用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"Unnamed"</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能，不再需要重复代码。</p>
<p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p>
<ol>
<li>编译器会默认给所有类加上 <code>extends Object</code>。</li>
<li>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</li>
<li><code>private</code> 修饰的成员变量和方法无法访问，需要使用 <code>protected</code> 来修饰后才能用。</li>
<li>子类要使用在父类中定义的成员变量和方法时，可以通过使用 <code>super.变量名</code> 或 <code>this.变量名</code> 或 <code>变量名</code> ，效果都是一样的，编译器会自动定位到父类的相应位置。</li>
<li>局部变量、子类成员变量、父类成员变量同名情况，调用规则如下：<ul>
<li>局部变量：直接写变量名</li>
<li>子类成员变量：<code>this.成员变量名</code></li>
<li>父类成员变量：<code>super.成员变量名</code></li>
</ul>
</li>
<li>子类构造方法中第一行<strong>必须</strong>调用父类构造方法，如果没有明确调用，编译器会自动加上 <code>super();</code></li>
<li>当子类和父类中有<strong>重名的成员变量</strong>，获取成员变量的规则如下：<ul>
<li>如果是 <code>子类·成员变量</code> ，那么优先调用的是子类的成员变量。</li>
<li>如果是 <code>子类·成员方法</code>，那么优先调用<strong>该方法所在类中</strong>的成员变量。</li>
</ul>
</li>
<li>子类方法的返回值类型范围必须<strong>小于等于</strong>父类方法的返回值类型范围。</li>
<li>子类方法的权限必须<strong>大于等于</strong>父类方法的权限修饰符<ul>
<li>例如，父类方法权限是 <code>protected</code> ，子类重写该方法，权限只能选择 <code>public</code> 或 <code>protected</code>。</li>
</ul>
</li>
</ol>
<h3 id="super-的三种用法"><a href="#super-的三种用法" class="headerlink" title="super 的三种用法"></a>super 的三种用法</h3><ol>
<li><code>super·成员变量;</code> 使用父类成员变量。</li>
<li><code>super·成员方法;</code> 使用父类成员方法。</li>
<li><code>super();</code> 使用父类构造方法。</li>
</ol>
<h3 id="this-的三种用法"><a href="#this-的三种用法" class="headerlink" title="this 的三种用法"></a>this 的三种用法</h3><ol>
<li><code>this·成员变量;</code> 调用本类成员变量。</li>
<li><code>this·成员方法;</code> 调用本类成员方法。</li>
<li><code>this();</code> 调用子类其他的构造方法。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>
<p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();</span><br><span class="line">        p.run(); <span class="comment">// 实际使用 Student.run</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java的实例方法调用是基于<u>运行时</u>的<u>实际类型</u>的动态调用，而非变量的声明类型，这个非常重要的特性在面向对象编程中称之为多态。</strong></p>
<p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</p>
<p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>。</p>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承。</p>
<p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。</p>
<p>可以在构造方法中初始化final字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一：直接初初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name = <span class="string">"Unamed"</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 方法二：先定义，构造函数再初始化    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li><p><code>abstruct</code> 修饰的类是抽象类，抽象类无法实例化。</p>
</li>
<li><p>因为抽象类本身被设计成只能用于被继承，因此，<strong>抽象类可以强迫子类实现其定义的所有抽象方法</strong>，<strong>或者子类也成为抽象类</strong>，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>
</li>
<li><p>抽象类仍然可以当做向上转型的引用类型，体现多态。</p>
</li>
<li><p>抽象类中通过 <code>abstruct</code> 修饰的抽象方法，不能有方法体。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">// 不能有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类中仍可以定义普通方法，子类可以调用普通方法。</p>
</li>
<li><p>抽象类中可以没有抽象方法，但有抽象方法的类一定是抽象类。</p>
</li>
<li><p>抽象类中定义的方法，在后续的子类中必须逐渐把所有的抽象方法实现，否则也要定义成抽象类，给更后面的子类把未实现的抽象方法实现。而前面的类已经实现了的方法，就不强制要求实现了，要么默认使用，要么可以选择重写的方式来使用。</p>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口。</p>
<ol>
<li><p><code>interface</code> 中定义的方法，子类在 <code>implements</code> 后必须覆写里面的方法，或者转为抽象类，否则报错。</p>
</li>
<li><p><code>interface</code> 中定义的字段默认都是 <code>public static final</code> 修饰的，<strong>只能在声明时初始化</strong>，不能再变。常量以全大写字母命名，多单词之间用下划线分割，如 <code>public static final int TOTAL_MONEY = 10;</code>。</p>
</li>
<li><p>一个类可以多次<code>implements interface</code> 。</p>
</li>
<li><p>接口之间可以是是多继承关系的，如果多个父接口中的默认方法重复，子接口需要重写该默认方法，且带有 <code>default</code> 关键字。</p>
</li>
<li><p><code>interface</code> 中的方法可以被 <code>default</code> 修饰。<code>default</code> 修饰的方法可以不强制在所有子类都实现，只在需要用到地方覆写即可。</p>
</li>
<li><p><code>interface</code> 中定义的方法默认都是 <code>public abstract</code> 修饰的，可以不写，也可以只写任意一部分。方法的三要素（返回值类型、方法名、形参列表）可以随意定义。</p>
</li>
<li><p>Java 8 开始<code>interface</code> 中可以定义<strong>静态方法</strong>，通过 <code>接口名·静态方法名</code> 直接使用。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> 方法名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 9 开始 <code>interface</code> 中可以定义普通私有方法、静态私有方法，以解决接口中代码重复的问题而不暴露给实现类使用：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    <span class="comment">// 定义普通私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义静态私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个接口中有重复的默认方法，实现类必须重写该默认方法。</p>
</li>
<li><p>两个接口中有重复的抽象方法，实现类只需要重写一次该抽象方法。</p>
</li>
<li><p>继承的父类和实现的接口中有重名的默认方法，优先调用父类方法。</p>
</li>
</ol>
<h3 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h3><ol>
<li>静态字段、静态方法并不专属于某个实例，它们是唯一且公共的。</li>
<li>不推荐 <code>实例名·静态字段</code> 的方式去访问静态字段，实际上是编译器自动根据实例类型转化为 <code>类名·静态字段</code> 的方式来访问，静态方法的情况同理。</li>
<li>静态方法中不能使用 <code>this</code> ，因为它不属于实例，只能访问静态字段和其他静态方法。</li>
<li>静态方法常用于工具类和辅助方法。</li>
<li>静态方法中访问不到非静态的内容，因为内存中是先存在静态内容，后存在非静态内容。</li>
</ol>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ol>
<li>静态代码块优先于非静态代码执行，与代码先后顺序无关。</li>
<li>静态代码块<strong>只在</strong>第一次使用本类时执行。</li>
<li>适用于一次性对静态成员变量进行赋值。</li>
</ol>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ol>
<li><p><code>public</code>：可以被任意访问</p>
</li>
<li><p><code>protected</code>：可以被同包的类，和任意包的子类访问</p>
</li>
<li><p><code>default(package)</code>：可以被同包的类访问</p>
</li>
<li><p><code>private</code>：只能被自身内部访问</p>
</li>
<li><p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。</p>
</li>
<li><p>如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>
</li>
</ol>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ol>
<li><p>在<strong>方法内部</strong>定义的变量称为局部变量。</p>
</li>
<li><p>局部变量作用域从变量声明处开始到对应的块结束。</p>
</li>
<li><p>方法参数也是局部变量。</p>
</li>
</ol>
<h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><ol>
<li><code>final</code> 修饰 <code>class</code>，可以阻止类被<strong>继承</strong>。</li>
<li><code>final</code> 修饰 <code>method</code>，可以阻止方法被子类<strong>覆写</strong>。</li>
<li><code>final</code> 修饰 <code>field</code>，可以阻止字段被<strong>重新赋值</strong>。</li>
<li><code>final</code> 修饰局部变量，可以阻止被<strong>重新赋值</strong>。</li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><strong>泛型就是编写模板代码来适应任意类型。</strong></p>
<p>情况一：编写一个 String 类型的 ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况二：编写一个 Integer类型的 ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此会造成代码的重复，泛型就是定义一种类型的模板，这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 ArrayList 实现了接口 List，所以泛型可以先上转型。</p>
<p><strong>注意：泛型类型&lt;T&gt;不能用于静态方法。</strong></p>
<h3 id="多个泛型"><a href="#多个泛型" class="headerlink" title="多个泛型"></a>多个泛型</h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，需要指出两种类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">"test"</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>字符串的内容永不可变，是常量，可以被共享。</li>
<li><code>String</code> 类型的字符是存储在 <code>byte[]</code> 中的。</li>
<li>通过 <code>String s = &quot;abc&quot;;</code> 字面量方式创建的字符串常量存储在 <code>字符串常量池</code> 中。</li>
<li>通过 <code>Sting s = new Sting();</code> 实例化创建出来的字符串在独立的堆内存中。</li>
<li>直接打印 <code>String</code>、<code>char[]</code> 是可以显示字符串的，如果是其他类型数组会打印地址值。</li>
<li>通过 <code>==</code> 比较的是字符串的内存地址。</li>
<li>通过 <code>字符串1.equals(字符串2);</code> 的方法可以比较字符串<strong>内容</strong>是否相同。</li>
<li>通过 <code>字符串1.equalsIgnoreCase(字符串2);</code> 的方法可以比较内容<strong>忽略大小写</strong>是否相同。</li>
</ol>
<p><img src="/Users/hxj/Documents/GitHub/hexo/Blog/source/_posts/image-20200310215114574.png" alt="image-20200310215114574"></p>
<h3 id="Object-toString"><a href="#Object-toString" class="headerlink" title="Object.toString()"></a>Object.toString()</h3><ol>
<li>默认情况下，如果一个类没有重写 toString 方法，那么使用 toString 方法得到的是内存地址。如果重写 toString 方法，将可以得到需要显示的格式。</li>
<li>可以根据自身需求，重写 toString 方法。</li>
</ol>
<h3 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h3><p> <strong>== 的作用：</strong><br>　　基本类型：比较的就是<strong>值</strong>是否相同。<br>　　引用类型：比较的就是<strong>地址值</strong>是否相同。<br><strong>equals 的作用:</strong><br>　　引用类型：默认情况下，比较的是<strong>地址值</strong>。</p>
<p><strong>String类的equals()方法：其实是比较两个字符串的内容。</strong></p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ol>
<li><code>String</code> 类型每次操作都会产生新的字符串对象，然后扔掉旧的字符串，容易浪费内存，影响GC效率。</li>
<li>为了高效的拼接字符串，<code>StringBuilder</code> 是一个可变对象，往其中增加新字符时，不会创建新的对象，切支持链式操作（函数调用返回 <code>this</code>）。</li>
<li><code>StringBuilder</code> 的方法不是线程安全的（不能同步访问）但执行速度更快，<code>StringBuffer</code> 的方法是线程安全的（同步访问），但同步会带来执行速度的下降。</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// main 方法本身就处在JVM进程创建的主线程中运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread tr = <span class="keyword">new</span> Thread(); <span class="comment">// 实例化进程对象</span></span><br><span class="line">        tr.start(); <span class="comment">// 启用新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>新线程的执行需要调用 <code>线程·start();</code> 方法，但默认什么也不做。</li>
<li>可以从 <code>Thread</code> 类中派生一个自定义类，并覆写 <code>run()</code> 方法。执行 <code>start()</code> 方法的时候会自动调用实例的 <code>run()</code> 方法，主线程和子线程就开始同时运行了。一旦<code>run()</code>方法执行完毕，线程就结束了。</li>
<li>主线程和子线程的运行顺序是不一定的，由操作系统决定调度顺序。</li>
<li>可以使用 <code>Thread.slepp(int 毫秒数)</code>，强迫当前线程暂停指定时间。</li>
<li>直接调用 <code>线程·run();</code> 方法是无效的，只会被当做普通方法执行。必须要通过 <code>start()</code> 方法才能启动新线程，由 JVM 内部实现， <code>start()</code> 方法只能调用一次。</li>
<li>设置线程优先级 <code>Thread.setPriority(int n)</code> ，1~10，默认值5。</li>
<li>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</li>
</ol>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>线程的状态：</p>
<ol>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>
<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>
</ol>
<p>线程终止的原因有：</p>
<ul>
<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>
<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>
<p>调用 <code>线程·join()</code> ，可以让一个线程等待指定线程结束后才开始执行。也可以使用 <code>线程·join(long n)</code>指定等待时间，超过时间后不再继续等待。</p>
<p>如果线程已经结束再调用 <code>线程·join()</code>  会立刻返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread tr = <span class="keyword">new</span> Thread();</span><br><span class="line">        tr.start();</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tr.join(); <span class="comment">// 主线程等待 tr 线程结束后才开始执行</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中断进程"><a href="#中断进程" class="headerlink" title="中断进程"></a>中断进程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread tr = <span class="keyword">new</span> Thread();</span><br><span class="line">        tr.start();</span><br><span class="line">        </span><br><span class="line">        mt.interrupt(); <span class="comment">// 中断 mt 进程</span></span><br><span class="line"></span><br><span class="line">        tr.join(); <span class="comment">// 主线程等待 tr 线程结束后才开始执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>线程·interrupt()</code> 方法可以中断指定线程。</p>
</li>
<li><p>指定进程中通过 <code>isInterrupted()</code> 检测自身状态是否被中断。</p>
</li>
<li><p>如果指定进程处在等待状态中，那么会抛出 <code>InterruptedException</code> 异常，并结束本线程运行。</p>
</li>
<li><p>可以设置进程间共享的变量来控制中断： 设置 <code>voladile</code> 关键字，确保每个进程都能读取到更新后的变量值，如： <code>public volatile boolean running = true;</code>。</p>
</li>
<li><p>使用 <code>voladile</code> 的原因：</p>
<ul>
<li><p>java的内存模型中，分为主内存和工作内存。变量的值保存在主内存中，当线程访问变量时，会获取变量的副本保存在自己的工作内存中。虚拟机会在某个时刻将修改后的变量副本值写会回主内存中，可能会造成其他线程访问该变量时，获取到的仍是旧值。</p>
<p>使用 <code>voladile</code>关键字的作用：</p>
</li>
<li><p>每次访问变量时，总是获取主内存的最新值；</p>
</li>
<li><p>每次修改变量后，立刻回写到主内存。</p>
</li>
</ul>
</li>
<li><p>通过 <code>线程名·running = false;</code> 结合线程中的条件判断，可以控制线程的中断。</p>
</li>
</ol>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ol>
<li><p>Java程序入口是由JVM启动 <code>main</code> 线程，<code>main</code> 线程由可以启动其他线程。当所有线程运行结束时，JVM退出，进程结束。</p>
</li>
<li><p>如果有一个线程没有退出，则 JVM 就不会退出，必须等到所有线程结束才行。</p>
</li>
<li><p>对于某些执行定时任务的线程，最后可能没有其他线程能控制它的结束，需要把它设置为<strong>守护进程</strong>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line"><span class="comment">// 在 t.start() 前设置进程为守护进程</span></span><br><span class="line">t.setDaemon();</span><br><span class="line">t.start();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>守护线程是指为其他线程服务的线程。当JVM中的非守护线程运行结束后，无论是否还有守护线程，JVM 都会推出。</p>
</li>
</ol>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol>
<li><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
</li>
<li><p>对于共享的变量，可能会由于多个线程同时对其进行读写导致数据的不一致。需要同步的方式（上锁、解锁），使得对共享变量的修改权限仅供某一个线程使用，待其操作结束后解锁，其他线程才能继续访问修改共享变量。</p>
</li>
<li><p>通过 <code>synchronized</code> 关键字设置临界区，解决共享变量正确性问题：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// synchronized 针对锁对象进行上锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">		临界区</span><br><span class="line">    &#125; <span class="comment">// 代码块结束后，自动解锁</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个线程要实现同步，必须针对的都是同一个锁对象才行，否则无法同步。</p>
</li>
<li><p><code>synchronized</code>会带来性能下降，其中的代码块无法并发操作，且上锁解锁需要消耗一定的时间，降低程序执行效率。 </p>
</li>
<li><p>不需要 <code>synchronized</code> 的情况：</p>
<ol>
<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>
<li>引用类型赋值，例如：<code>List list = anotherList</code>。</li>
</ol>
</li>
</ol>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ol>
<li><p>让线程自动选择上锁的对象容易导致代码逻辑混乱，不利于封装。在一个类中，可以把 <code>synchronized</code> 锁定对象变为自身实例 <code>this</code>：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe)。</p>
</li>
<li><p>大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>
</li>
<li><p>用<code>synchronized</code>修饰的方法就是同步方法，它表示<strong>整个方法</strong>都必须用<code>this</code>实例加锁。等价写法：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; <span class="comment">// 锁住this</span></span><br><span class="line">        count += n;</span><br><span class="line">    &#125; <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 锁住this</span></span><br><span class="line">    count += n;</span><br><span class="line">&#125; <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于类的静态方法添加 <code>synchronized</code> 修饰符，锁住的是该类的 <code>class</code> 实例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><ol>
<li><p>Java的线程锁是可重入的锁。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁。</p>
<p> JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p>
<p> 由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>
</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在 Java 中，如果一个 Java 对象可以在内部持有若干其他 Java 对象，并对外提供访问接口，我们把这种 Java 对象称为集合。</p>
<p>Java 标准库自带的 <code>java.util</code> 包主要提供了以下三种集合：</p>
<ul>
<li><code>List</code>：一种有序列表的集合。</li>
<li><code>Set</code>：一种保证没有重复元素的集合。</li>
<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合。</li>
</ul>
<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素。</p>
<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><code>List</code> 是最基础的集合，它是一种<strong>有序链表</strong>。</p>
<p><code>List</code> 行为几乎和数组一样，按放入的顺序保存元素，可以通过索引确认位置，索引从 <code>0</code> 开始。</p>
<p>实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。</p>
<p>特点：</p>
<ul>
<li><code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复。</li>
<li><code>List</code>还允许添加<code>null</code>。</li>
</ul>
<p>创建 <code>List</code> ，使用 <code>List.of()</code> 方法。但不接受 <code>null</code> 值，如果传入 <code>null</code>，会抛出<code>NullPointerException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><code>List.of()</code> 方法生成的是 <code>List</code> 是只读的，不能进行修改。</p>
<p>我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p>
<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">            String s = it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用 for each 循环同样效果，更简洁</span></span><br><span class="line">         <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>List</code>中查找元素时，<code>List</code>的实现类通过元素的<code>equals()</code>方法比较两个元素是否相等，因此，放入的元素必须正确覆写<code>equals()</code>方法，Java标准库提供的<code>String</code>、<code>Integer</code>等已经覆写了<code>equals()</code>方法；</li>
<li>编写<code>equals()</code>方法可借助<code>Objects.equals()</code>判断。</li>
<li>如果不在<code>List</code>中查找元素，就不必覆写<code>equals()</code>方法。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p>
<p><code>Map</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>
<p><code>Map</code>中不存在重复的<code>key</code>，因为放入相同的<code>key</code>，只会把原有的<code>key-value</code>对应的<code>value</code>给替换掉。返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p>
<p>遍历Map，对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"apple"</span>, <span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">"pear"</span>, <span class="number">456</span>);</span><br><span class="line">        map.put(<span class="string">"banana"</span>, <span class="number">789</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            Integer value = map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="http://47.98.43.70">项目</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础概念"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#术语："><span class="toc-number">1.1.</span> <span class="toc-text">术语：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令行窗口命令："><span class="toc-number">1.2.</span> <span class="toc-text">命令行窗口命令：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型："><span class="toc-number">1.3.</span> <span class="toc-text">基本数据类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-number">1.4.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义方法"><span class="toc-number">1.5.</span> <span class="toc-text">定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载"><span class="toc-number">1.6.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建数组"><span class="toc-number">1.7.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的三个特征"><span class="toc-number">1.8.</span> <span class="toc-text">面向对象的三个特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的定义"><span class="toc-number">1.9.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的成员变量和成员方法"><span class="toc-number">1.10.</span> <span class="toc-text">类的成员变量和成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的构造方法"><span class="toc-number">1.11.</span> <span class="toc-text">类的构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的继承"><span class="toc-number">1.12.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-的三种用法"><span class="toc-number">1.13.</span> <span class="toc-text">super 的三种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-的三种用法"><span class="toc-number">1.14.</span> <span class="toc-text">this 的三种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">1.15.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">1.16.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">1.17.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态字段和静态方法"><span class="toc-number">1.18.</span> <span class="toc-text">静态字段和静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态代码块"><span class="toc-number">1.19.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问权限"><span class="toc-number">1.20.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部变量"><span class="toc-number">1.21.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-修饰符"><span class="toc-number">1.22.</span> <span class="toc-text">final 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型"><span class="toc-number">1.23.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个泛型"><span class="toc-number">1.24.</span> <span class="toc-text">多个泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.25.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-toString"><span class="toc-number">1.26.</span> <span class="toc-text">Object.toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等比较"><span class="toc-number">1.27.</span> <span class="toc-text">相等比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.28.</span> <span class="toc-text">StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建多线程"><span class="toc-number">2.1.</span> <span class="toc-text">创建多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程的状态"><span class="toc-number">2.2.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断进程"><span class="toc-number">2.3.</span> <span class="toc-text">中断进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程"><span class="toc-number">2.4.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">2.5.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步方法"><span class="toc-number">2.6.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁"><span class="toc-number">2.7.</span> <span class="toc-text">可重入锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">3.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">3.2.</span> <span class="toc-text">Map</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2020/03/22/JavaSE学习笔记/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&text=JavaSE学习笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&is_video=false&description=JavaSE学习笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=JavaSE学习笔记&body=Check out this article: http://yoursite.com/2020/03/22/JavaSE学习笔记/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&title=JavaSE学习笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2020/03/22/JavaSE学习笔记/&name=JavaSE学习笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 HXJ
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="http://47.98.43.70">项目</a></li>
         
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
